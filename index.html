<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Penguin Evolution: Ice Age</title>
    <style>
        body { margin: 0; background: #cceeff; color: #004466; font-family: 'Segoe UI', sans-serif; overflow: hidden; user-select: none; }
        
        canvas { 
            display: block; cursor: crosshair; margin-right: 280px; 
            /* Complex CSS gradient for base ice color */
            background: radial-gradient(circle at 50% 50%, #f0faff 0%, #dbeeff 60%, #b3d9ff 100%);
        }
        
        /* UI PANEL */
        #lab-panel {
            position: absolute; right: 0; top: 0; bottom: 0; width: 280px;
            background: linear-gradient(to bottom, #1a2a3a, #0d1520); 
            border-left: 4px solid #55aaff;
            padding: 15px; display: flex; flex-direction: column;
            color: white;
            box-shadow: -5px 0 20px rgba(0, 0, 0, 0.5);
            z-index: 10;
        }

        h2 { color: #55aaff; margin: 0 0 10px 0; font-size: 20px; text-transform: uppercase; border-bottom: 1px solid #335577; padding-bottom: 5px; }
        .resource { font-size: 24px; color: #00ffaa; font-weight: bold; margin-bottom: 5px; }
        .sub-res { font-size: 12px; color: #88ccaa; margin-bottom: 15px; }
        
        #dna-inventory {
            flex-grow: 1; overflow-y: auto; display: flex; flex-direction: column; gap: 6px;
            margin-bottom: 10px; padding-right: 5px;
        }
        
        /* CUSTOM SCROLLBAR */
        #dna-inventory::-webkit-scrollbar { width: 6px; }
        #dna-inventory::-webkit-scrollbar-thumb { background: #335577; border-radius: 3px; }

        .dna-item {
            background: #253545; padding: 10px; border-radius: 6px; cursor: pointer;
            display: flex; justify-content: space-between; align-items: center;
            border: 1px solid #334455; transition: 0.2s;
        }
        .dna-item:hover { background: #304050; border-color: #55aaff; transform: translateX(-2px); }
        
        /* SELECTION STYLES */
        .dna-item.selected-1 { border: 2px solid #00ffaa; background: #1a3a4a; box-shadow: 0 0 10px rgba(0,255,170,0.2); }
        .dna-item.selected-2 { border: 2px solid #aa00ff; background: #2a1a3a; box-shadow: 0 0 10px rgba(170,0,255,0.2); }
        
        #unit-inspector {
            height: 220px; background: #101820; border-radius: 8px; padding: 15px;
            border: 1px solid #335577; display: none; flex-direction: column;
        }
        .slot {
            background: #000; height: 35px; margin: 5px 0; border: 1px dashed #446688; border-radius: 4px;
            display: flex; align-items: center; justify-content: center; font-size: 13px; color: #6688aa;
        }
        .slot.filled { border: 1px solid #55aaff; color: #fff; background: #003344; font-weight: bold; text-shadow: 0 0 5px #00aaff; }

        button {
            background: #55aaff; color: #002233; border: none; padding: 12px;
            font-weight: bold; cursor: pointer; margin-top: auto; border-radius: 6px;
            text-transform: uppercase; letter-spacing: 1px; transition: 0.2s;
        }
        button:hover:not(:disabled) { background: #88ccff; box-shadow: 0 0 15px #55aaff; }
        button:disabled { background: #334455; color: #556677; cursor: not-allowed; }
        
        /* GAME OVER MENU */
        #game-over-menu {
            position: absolute; top: 0; left: 0; right: 280px; bottom: 0;
            background: rgba(0, 20, 40, 0.85);
            display: none; align-items: center; justify-content: center; flex-direction: column;
            backdrop-filter: blur(5px); z-index: 20;
        }
        .go-title { font-size: 50px; color: white; font-weight: bold; text-shadow: 0 0 20px #00aaff; margin-bottom: 20px; }
        .go-btn {
            background: #ffaa00; color: black; font-size: 24px; padding: 15px 40px;
            border: none; border-radius: 50px; cursor: pointer; font-weight: bold;
            box-shadow: 0 0 20px rgba(255, 170, 0, 0.5); transition: 0.2s;
        }
        .go-btn:hover { transform: scale(1.1); background: #ffcc00; }

        #msg-overlay {
            position: absolute; top: 20px; left: 20px; pointer-events: none;
            background: rgba(255,255,255,0.7); padding: 15px; border-radius: 10px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.1); border: 2px solid #fff;
            color: #003344;
        }
    </style>
</head>
<body>

    <div id="msg-overlay">
        <h3 style="margin:0; color:#006699">üêß ICE AGE UPDATE</h3>
        <div>1. Select up to <b>2 Mutations</b> at once.</div>
        <div>2. You start with <b>10 Penguins</b>.</div>
        <div>3. Defeated enemies still join your team!</div>
        <div style="color:#008800; margin-top:5px; font-weight:bold;">Defend the Frozen Lake!</div>
    </div>

    <div id="game-over-menu">
        <div class="go-title">COLONY LOST</div>
        <button class="go-btn" onclick="location.reload()">TRY AGAIN</button>
    </div>

    <div id="lab-panel">
        <h2>Biomass</h2>
        <div id="bioDisplay" class="resource">1000</div>
        <div class="sub-res">+10 generated / sec</div>
        
        <h2>DNA Freezer</h2>
        <div id="dna-inventory"></div>

        <div id="unit-inspector">
            <h3 style="margin:0; font-size:14px; color:#55aaff; border-bottom:1px solid #333; padding-bottom:5px;">Penguin Modding</h3>
            <div class="slot" id="slot1">Empty Gene Slot</div>
            <div class="slot" id="slot2">Empty Gene Slot</div>
            <button id="btnInject" onclick="injectMutation()">INJECT GENE</button>
        </div>
    </div>

    <canvas id="simCanvas"></canvas>

<script>
const canvas = document.getElementById('simCanvas');
const ctx = canvas.getContext('2d');
canvas.width = window.innerWidth - 280; 
canvas.height = window.innerHeight;

// -- CONFIG --
const MUTATIONS = {
    LASER: { name: 'Laser Eyes', color: '#ff0055', type: 'range' },
    SHOTGUN: { name: 'Snow Blaster', color: '#ffffff', type: 'range' },
    SNIPER: { name: 'Icicle Sniper', color: '#00ff00', type: 'range' },
    MISSILE: { name: 'Fish Missile', color: '#ffaa00', type: 'range' },
    SPIKES: { name: 'Spiked Armor', color: '#555555', type: 'melee' },
    SAW: { name: 'Buzz Saw', color: '#cccccc', type: 'melee' },
    SHIELD: { name: 'Bubble Shield', color: '#00ffff', type: 'tank' },
    HEALER: { name: 'Medic Aura', color: '#00ffaa', type: 'support' },
    TESLA: { name: 'Shock Coil', color: '#ffff00', type: 'melee' },
    REPULSE: { name: 'Wind Blower', color: '#ff00ff', type: 'tank' },
    NUKE: { name: 'Nuke', color: '#33ff00', type: 'tank' },
    GRAVITY: { name: 'Vacuum', color: '#220044', type: 'support' },
    BLINK: { name: 'Teleporter', color: '#aa00ff', type: 'melee' },
    FLAME: { name: 'Flamethrower', color: '#ff4400', type: 'range' }
};

const MUTATION_KEYS = Object.keys(MUTATIONS);

// -- GAME STATE --
let biomass = 1000;
let gameTime = 0;
let army = [];
let enemies = [];
let items = []; 
let projectiles = [];
let particles = [];
let inventory = {}; 
let selectedUnit = null;
let selectedDNA = []; // CHANGED TO ARRAY FOR MULTI-SELECT
let isGameOver = false;

// Initialize Inventory
MUTATION_KEYS.forEach(k => inventory[k] = 0);

// STARTER PACK
inventory['LASER'] = 2;
inventory['SPIKES'] = 2;
inventory['SHIELD'] = 2;
inventory['SHOTGUN'] = 2;
inventory['HEALER'] = 2;
inventory['MISSILE'] = 1;

// -- GENERATE ICE TEXTURE --
// We generate a list of "cracks" and "patches" once to draw them every frame without lag
const iceCracks = [];
const icePatches = [];

function generateIce() {
    // Generate Cracks (Jagged lines)
    for(let i=0; i<15; i++) {
        let x = Math.random() * canvas.width;
        let y = Math.random() * canvas.height;
        let crack = [{x, y}];
        let len = 5 + Math.random() * 10;
        let angle = Math.random() * Math.PI * 2;
        
        for(let j=0; j<len; j++) {
            x += Math.cos(angle) * (10 + Math.random()*20);
            y += Math.sin(angle) * (10 + Math.random()*20);
            angle += (Math.random() - 0.5) * 1.5; // Jagged turns
            crack.push({x, y});
        }
        iceCracks.push(crack);
    }
    
    // Generate Frost Patches
    for(let i=0; i<8; i++) {
        icePatches.push({
            x: Math.random() * canvas.width,
            y: Math.random() * canvas.height,
            r: 50 + Math.random() * 100
        });
    }
}
generateIce();

function drawBackground() {
    // 1. Frost Patches
    ctx.fillStyle = "rgba(255, 255, 255, 0.15)";
    icePatches.forEach(p => {
        ctx.beginPath();
        ctx.arc(p.x, p.y, p.r, 0, Math.PI*2);
        ctx.fill();
    });

    // 2. Deep Cracks
    ctx.strokeStyle = "rgba(100, 150, 200, 0.4)";
    ctx.lineWidth = 2;
    iceCracks.forEach(line => {
        ctx.beginPath();
        ctx.moveTo(line[0].x, line[0].y);
        for(let i=1; i<line.length; i++) ctx.lineTo(line[i].x, line[i].y);
        ctx.stroke();
    });

    // 3. Surface Scratches (faint)
    ctx.strokeStyle = "rgba(255, 255, 255, 0.2)";
    ctx.lineWidth = 1;
    iceCracks.forEach(line => {
        ctx.beginPath();
        ctx.moveTo(line[0].x+2, line[0].y+2); // Offset slightly
        for(let i=1; i<line.length; i++) ctx.lineTo(line[i].x+2, line[i].y+2);
        ctx.stroke();
    });
}

// -- INPUTS --
let mouseX = 0, mouseY = 0;
canvas.addEventListener('mousemove', e => { mouseX = e.clientX; mouseY = e.clientY; });
canvas.addEventListener('mousedown', e => {
    let clicked = false;
    for(let u of army) {
        if(Math.hypot(u.x - mouseX, u.y - mouseY) < u.size + 15) {
            selectUnit(u);
            clicked = true;
            break;
        }
    }
    if(!clicked) deselectUnit();
});

// -- DRAWING --
function drawPenguin(ctx, x, y, vx, vy, size, angle, team, waddle, hpPerc, mutations) {
    ctx.save();
    ctx.translate(x, y);
    
    // -- SQUASH AND STRETCH --
    let speed = Math.hypot(vx, vy);
    let drawAngle = angle;
    let stretch = Math.min(speed * 0.05, 0.4); 
    ctx.rotate(drawAngle); 
    ctx.scale(1 + stretch, 1 - stretch); 
    ctx.rotate(-drawAngle); 
    
    ctx.rotate(angle); 
    ctx.rotate(Math.sin(waddle) * 0.2); 

    // 1. FEET
    ctx.fillStyle = "#ffaa00";
    ctx.beginPath(); ctx.ellipse(5, 5, 5, 3, 0, 0, Math.PI*2); ctx.fill(); 
    ctx.beginPath(); ctx.ellipse(5, -5, 5, 3, 0, 0, Math.PI*2); ctx.fill(); 

    // 2. MUTATIONS (UNDER)
    mutations.forEach(m => drawMutation(ctx, m, true, size));

    // 3. BODY
    let bodyColor = team === 'blue' ? '#0077aa' : '#cc4444';
    if(selectedUnit && selectedUnit.x === x && selectedUnit.y === y) {
        ctx.shadowBlur = 15; ctx.shadowColor = "#00ffaa";
    }

    ctx.fillStyle = bodyColor;
    ctx.beginPath();
    ctx.ellipse(0, 0, size * 1.2, size, 0, 0, Math.PI*2);
    ctx.fill();
    ctx.shadowBlur = 0;

    // 4. BELLY
    ctx.fillStyle = "white";
    ctx.beginPath();
    ctx.ellipse(2, 0, size * 0.9, size * 0.7, 0, 0, Math.PI*2);
    ctx.fill();

    // 5. EYES
    ctx.fillStyle = "black";
    ctx.beginPath(); ctx.arc(6, -4, 2, 0, Math.PI*2); ctx.fill(); 
    ctx.beginPath(); ctx.arc(6, 4, 2, 0, Math.PI*2); ctx.fill(); 
    ctx.fillStyle = "white"; 
    ctx.beginPath(); ctx.arc(7, -5, 0.5, 0, Math.PI*2); ctx.fill();
    ctx.beginPath(); ctx.arc(7, 3, 0.5, 0, Math.PI*2); ctx.fill();
    
    if(team === 'red') {
        ctx.strokeStyle = "black"; ctx.lineWidth = 1;
        ctx.beginPath(); ctx.moveTo(4, -7); ctx.lineTo(8, -2); ctx.stroke();
        ctx.beginPath(); ctx.moveTo(4, 7); ctx.lineTo(8, 2); ctx.stroke();
    }

    // 6. BEAK
    ctx.fillStyle = "#ffaa00";
    ctx.beginPath(); ctx.moveTo(10, -2); ctx.lineTo(18, 0); ctx.lineTo(10, 2); ctx.fill();

    // 7. WINGS
    ctx.fillStyle = bodyColor;
    ctx.beginPath(); ctx.ellipse(-5, -size, 8, 3, Math.PI/4, 0, Math.PI*2); ctx.fill();
    ctx.beginPath(); ctx.ellipse(-5, size, 8, 3, -Math.PI/4, 0, Math.PI*2); ctx.fill();

    // 8. MUTATIONS (OVER)
    mutations.forEach(m => drawMutation(ctx, m, false, size));

    // 9. HP BAR
    ctx.rotate(-Math.sin(waddle) * 0.2); 
    ctx.rotate(-angle); 
    ctx.scale(1/(1 + stretch), 1/(1 - stretch));
    
    ctx.fillStyle = "rgba(0,0,0,0.5)"; ctx.fillRect(-15, -25, 30, 6);
    ctx.fillStyle = hpPerc > 0.5 ? "#00ff00" : "#ff0000"; 
    ctx.fillRect(-14, -24, 28 * hpPerc, 4);

    ctx.restore();
}

function drawMutation(ctx, key, isUnder, size) {
    if(isUnder) {
        if(key === 'SPIKES') { ctx.fillStyle = "#555"; for(let i=0; i<6; i++) { ctx.rotate(1); ctx.beginPath(); ctx.moveTo(size, -3); ctx.lineTo(size+8, 0); ctx.lineTo(size, 3); ctx.fill(); } }
        if(key === 'SAW') { ctx.rotate(Date.now()/100); ctx.fillStyle = "#bbb"; ctx.beginPath(); for(let i=0; i<8; i++) { ctx.rotate(Math.PI/4); ctx.lineTo(size+12, 0); ctx.lineTo(size+4, 4); } ctx.fill(); }
        if(key === 'SHIELD') { ctx.strokeStyle = "rgba(0,255,255,0.6)"; ctx.lineWidth = 3; ctx.beginPath(); ctx.arc(0,0, size+10, 0, Math.PI*2); ctx.stroke(); }
        if(key === 'REPULSE') { ctx.strokeStyle = "magenta"; ctx.lineWidth=2; ctx.beginPath(); ctx.arc(0,0,size+5, 0, Math.PI*2); ctx.stroke(); }
        if(key === 'HEALER') { ctx.fillStyle = "rgba(0,255,100,0.2)"; ctx.beginPath(); ctx.arc(0,0, 60, 0, Math.PI*2); ctx.fill(); }
    } else {
        if(key === 'LASER') { ctx.fillStyle = "#333"; ctx.fillRect(-5, -18, 15, 6); ctx.fillStyle="red"; ctx.fillRect(10, -17, 2, 4); }
        if(key === 'SNIPER') { ctx.fillStyle = "#222"; ctx.fillRect(-5, -18, 25, 4); ctx.fillStyle="#0f0"; ctx.fillRect(20, -18, 4, 4); }
        if(key === 'SHOTGUN') { ctx.fillStyle = "#444"; ctx.fillRect(-5, -18, 12, 8); }
        if(key === 'FLAME') { ctx.fillStyle = "darkred"; ctx.fillRect(-5, -18, 14, 8); ctx.fillStyle="orange"; ctx.beginPath(); ctx.arc(9,-14,3,0,Math.PI*2); ctx.fill(); }
        if(key === 'MISSILE') { ctx.fillStyle = "#666"; ctx.fillRect(-5, -20, 10, 8); ctx.fillStyle="orange"; ctx.beginPath(); ctx.moveTo(5,-20); ctx.lineTo(12,-16); ctx.lineTo(5,-12); ctx.fill(); }
        if(key === 'TESLA') { ctx.fillStyle = "yellow"; ctx.beginPath(); ctx.arc(0,-15, 5, 0, Math.PI*2); ctx.fill(); }
        if(key === 'BOMB' || key === 'NUKE') { ctx.fillStyle = "black"; ctx.font = "16px Arial"; ctx.fillText("‚ò¢Ô∏è", -8, -15); }
    }
}

// -- CLASS --
class Creature {
    constructor(x, y, team, mutations = []) {
        this.id = Math.floor(Math.random()*10000);
        this.x = x; this.y = y;
        this.vx = 0; this.vy = 0;
        this.team = team;
        this.mutations = [...mutations];
        
        this.hp = 100; this.maxHp = 100;
        this.size = 14; 
        this.friction = 0.96; 
        this.accel = 0.25; 
        this.waddleOffset = Math.random() * 100;
        
        this.cooldowns = { slot0: 0, slot1: 0, melee: 0 };
        
        if(this.mutations.length > 0) {
            this.maxHp += 50 * this.mutations.length;
            this.hp = this.maxHp;
        }
    }

    isRanged() { return this.mutations.some(m => MUTATIONS[m].type === 'range'); }

    update() {
        this.vx *= this.friction;
        this.vy *= this.friction;

        const margin = 50;
        const pushBack = 0.5;
        if(this.x < margin) this.vx += pushBack;
        if(this.x > canvas.width - margin) this.vx -= pushBack;
        if(this.y < margin) this.vy += pushBack;
        if(this.y > canvas.height - margin) this.vy -= pushBack;


        let target = this.findTarget();

        if (target) {
            let dx = target.x - this.x;
            let dy = target.y - this.y;
            let dist = Math.hypot(dx, dy);
            let angleToTarget = Math.atan2(dy, dx);
            this.angle = angleToTarget;

            if (this.isRanged()) {
                let optimal = 200;
                if (dist > optimal) {
                    this.vx += Math.cos(angleToTarget) * this.accel;
                    this.vy += Math.sin(angleToTarget) * this.accel;
                } else if (dist < optimal - 50) {
                    this.vx -= Math.cos(angleToTarget) * (this.accel * 0.8);
                    this.vy -= Math.sin(angleToTarget) * (this.accel * 0.8);
                }
            } else {
                if (dist < 120 && this.cooldowns.melee <= 0) {
                    this.vx += Math.cos(angleToTarget) * 6;
                    this.vy += Math.sin(angleToTarget) * 6;
                    this.cooldowns.melee = 50; 
                    createParticles(this.x, this.y, "white", 3);
                } else {
                    this.vx += Math.cos(angleToTarget) * this.accel;
                    this.vy += Math.sin(angleToTarget) * this.accel;
                }
            }

            // Abilities
            this.mutations.forEach((mut, index) => {
                let cdKey = 'slot'+index;
                if(this.cooldowns[cdKey] <= 0) this.useAbility(mut, target, dist, cdKey);
            });

            // Collision
            if(dist < this.size + target.size) {
                let dmg = 2;
                let impact = Math.hypot(this.vx, this.vy);
                if (impact > 2) dmg = 8;
                if (this.mutations.includes('SPIKES')) dmg += 10;
                if (this.mutations.includes('SAW')) dmg += 5;
                if (this.mutations.includes('TESLA')) dmg += 3;
                
                target.takeDamage(dmg);

                // Bounce
                let pushForce = 4;
                let pushDir = Math.atan2(this.y - target.y, this.x - target.x);
                this.vx = Math.cos(pushDir) * pushForce;
                this.vy = Math.sin(pushDir) * pushForce;
                target.vx = Math.cos(pushDir + Math.PI) * pushForce;
                target.vy = Math.sin(pushDir + Math.PI) * pushForce;
            }
        } else if (this.team === 'blue') {
            if(Math.hypot(mouseX-this.x, mouseY-this.y) > 100) {
                let a = Math.atan2(mouseY-this.y, mouseX-this.x);
                this.vx += Math.cos(a) * (this.accel * 0.5);
                this.vy += Math.sin(a) * (this.accel * 0.5);
                this.angle = a;
            }
        }

        // Separation
        let pool = this.team === 'blue' ? army : enemies;
        for(let other of pool) {
            if (other !== this) {
                let dx = this.x - other.x;
                let dy = this.y - other.y;
                let dist = Math.hypot(dx, dy);
                if (dist < this.size*2 && dist > 0) {
                    let push = (this.size*2 - dist) / 5;
                    let angle = Math.atan2(dy, dx);
                    this.vx += Math.cos(angle) * push * 0.1;
                    this.vy += Math.sin(angle) * push * 0.1;
                }
            }
        }

        this.x += this.vx;
        this.y += this.vy;
        
        if(this.x < 0) this.x = 0; if(this.x > canvas.width) this.x = canvas.width;
        if(this.y < 0) this.y = 0; if(this.y > canvas.height) this.y = canvas.height;

        if(this.cooldowns.slot0 > 0) this.cooldowns.slot0--;
        if(this.cooldowns.slot1 > 0) this.cooldowns.slot1--;
        if(this.cooldowns.melee > 0) this.cooldowns.melee--;
    }

    draw() {
        let speed = Math.hypot(this.vx, this.vy);
        let waddle = speed > 0.1 ? Math.sin((gameTime + this.waddleOffset) * 0.3) * 0.3 : 0;
        drawPenguin(ctx, this.x, this.y, this.vx, this.vy, this.size, this.angle, this.team, waddle, this.hp/this.maxHp, this.mutations);
    }

    findTarget() {
        let pool = this.team === 'blue' ? enemies : army;
        let best = null, minDist = 9999;
        for(let e of pool) {
            let d = Math.hypot(e.x - this.x, e.y - this.y);
            if(d < minDist) { minDist = d; best = e; }
        }
        return best;
    }

    useAbility(key, target, dist, cdKey) {
        if(key === 'LASER' && dist < 300) { spawnProj(this, target, 'LASER'); this.cooldowns[cdKey] = 40; }
        if(key === 'SHOTGUN' && dist < 200) { for(let i=-0.3; i<=0.3; i+=0.3) spawnProj(this, target, 'SHOTGUN', i); this.cooldowns[cdKey] = 60; }
        if(key === 'SNIPER' && dist < 600) { spawnProj(this, target, 'SNIPER'); this.cooldowns[cdKey] = 120; }
        if(key === 'FLAME' && dist < 120) { spawnProj(this, target, 'FLAME'); this.cooldowns[cdKey] = 5; }
        if(key === 'MISSILE' && dist < 450) { spawnProj(this, target, 'MISSILE'); this.cooldowns[cdKey] = 100; }
        
        if(key === 'BLINK' && dist > 150) {
            this.x = target.x + (Math.random()*60-30);
            this.y = target.y + (Math.random()*60-30);
            createParticles(this.x, this.y, "#aa00ff", 10);
            this.cooldowns[cdKey] = 100;
        }
        if(key === 'TESLA' && dist < 120) {
            drawLightning(this.x, this.y, target.x, target.y);
            target.takeDamage(10);
            this.cooldowns[cdKey] = 40;
        }
        if(key === 'REPULSE' && dist < 80) {
             let a = Math.atan2(target.y - this.y, target.x - this.x);
             target.vx += Math.cos(a) * 12;
             target.vy += Math.sin(a) * 12;
             this.cooldowns[cdKey] = 30;
        }
        if(key === 'HEALER') {
            let mates = this.team === 'blue' ? army : enemies;
            mates.forEach(m => {
                if(m !== this && Math.hypot(m.x-this.x, m.y-this.y) < 100) m.hp = Math.min(m.hp + 0.3, m.maxHp);
            });
        }
    }

    takeDamage(amt) {
        if(this.mutations.includes('SHIELD') && Math.random() < 0.3) {
            createParticles(this.x, this.y, "cyan", 2);
            return;
        }
        this.hp -= amt;
    }
}

class Projectile {
    constructor(owner, target, type, angleOffset = 0) {
        this.x = owner.x; this.y = owner.y;
        this.type = type; this.owner = owner;
        let a = Math.atan2(target.y - owner.y, target.x - owner.x) + angleOffset;
        this.vx = Math.cos(a); this.vy = Math.sin(a);
        this.target = target;
        
        let stats = {
            LASER: { spd: 8, life: 60, color: 'red', w: 3 },
            SNIPER: { spd: 15, life: 60, color: '#0f0', w: 2 },
            SHOTGUN: { spd: 6, life: 25, color: 'white', w: 4 },
            FLAME: { spd: 4, life: 20, color: 'orange', w: 6 },
            MISSILE: { spd: 3, life: 150, color: 'orange', w: 6 }
        };
        this.props = stats[type] || stats.LASER;
        this.vx *= this.props.spd; this.vy *= this.props.spd;
        this.life = this.props.life;
    }
    update() {
        if(this.type === 'MISSILE' && this.target && this.target.hp>0) {
            let a = Math.atan2(this.target.y-this.y, this.target.x-this.x);
            this.vx = Math.cos(a)*this.props.spd; this.vy = Math.sin(a)*this.props.spd;
        }
        this.x += this.vx; this.y += this.vy; this.life--;
        
        let pool = this.owner.team === 'blue' ? enemies : army;
        for(let t of pool) {
            if(Math.hypot(t.x-this.x, t.y-this.y) < t.size + 10) {
                let dmg = 10;
                if(this.type==='SNIPER') dmg = 40;
                if(this.type==='SHOTGUN') { dmg = 8; t.vx += this.vx*0.5; t.vy += this.vy*0.5; }
                if(this.type==='FLAME') dmg = 2;
                if(this.type==='MISSILE') { dmg=30; createExplosion(this.x,this.y, 40, "orange"); }
                t.takeDamage(dmg);
                this.life = 0; break;
            }
        }
    }
    draw() { ctx.fillStyle = this.props.color; ctx.beginPath(); ctx.arc(this.x, this.y, this.props.w, 0, Math.PI*2); ctx.fill(); }
}

function spawnDNA(x, y, type) { items.push({x, y, type, life: 1000}); }
function spawnProj(o, t, type, off=0) { projectiles.push(new Projectile(o, t, type, off)); }
function drawLightning(x1,y1,x2,y2) { ctx.strokeStyle="yellow"; ctx.beginPath(); ctx.moveTo(x1,y1); ctx.lineTo((x1+x2)/2+(Math.random()*20-10), (y1+y2)/2+(Math.random()*20-10)); ctx.lineTo(x2,y2); ctx.stroke(); }
function createExplosion(x,y,r,c) { ctx.fillStyle=c; ctx.globalAlpha=0.5; ctx.beginPath(); ctx.arc(x,y,r,0,Math.PI*2); ctx.fill(); ctx.globalAlpha=1; }
function createParticles(x,y,c,n) { for(let i=0; i<n; i++) particles.push({x,y,vx:(Math.random()-0.5)*5, vy:(Math.random()-0.5)*5,c,life:1}); }

// -- UI UPDATED FOR MULTI-SELECT --
function renderInventory() {
    const div = document.getElementById('dna-inventory'); div.innerHTML = "";
    MUTATION_KEYS.forEach(k => {
        if(inventory[k] > 0) {
            let el = document.createElement('div');
            // Check if selected
            let selIdx = selectedDNA.indexOf(k);
            let selClass = "";
            if (selIdx === 0) selClass = " selected-1";
            if (selIdx === 1) selClass = " selected-2";
            
            el.className = "dna-item" + selClass;
            el.innerHTML = `<span style="color:${MUTATIONS[k].color}">${MUTATIONS[k].name}</span> <span>x${inventory[k]}</span>`;
            
            el.onclick = () => { 
                // Toggle selection
                let idx = selectedDNA.indexOf(k);
                if (idx > -1) {
                    selectedDNA.splice(idx, 1); // Deselect
                } else {
                    if (selectedDNA.length < 2) selectedDNA.push(k); // Select if space
                }
                renderInventory(); 
                updateInspector(); 
            };
            div.appendChild(el);
        }
    });
}

function selectUnit(u) { selectedUnit = u; document.getElementById('unit-inspector').style.display='flex'; updateInspector(); }
function deselectUnit() { selectedUnit = null; document.getElementById('unit-inspector').style.display='none'; }

function updateInspector() {
    if(!selectedUnit) return;
    let slots = [document.getElementById('slot1'), document.getElementById('slot2')];
    
    // Reset slots visual
    slots[0].className = "slot"; slots[0].innerText = "Empty Gene Slot";
    slots[1].className = "slot"; slots[1].innerText = "Empty Gene Slot";
    
    // Fill with current mutations
    selectedUnit.mutations.forEach((m, i) => { 
        if(i<2) { 
            slots[i].className="slot filled"; 
            slots[i].style.color=MUTATIONS[m].color; 
            slots[i].innerText=MUTATIONS[m].name; 
        } 
    });

    let btn = document.getElementById('btnInject');
    let freeSlots = 2 - selectedUnit.mutations.length;
    let cost = 50 * selectedDNA.length;

    if(freeSlots > 0 && selectedDNA.length > 0 && biomass >= cost) {
        if(selectedDNA.length > freeSlots) {
             btn.disabled = true; 
             btn.innerText = "Too many genes selected";
        } else {
            btn.disabled = false; 
            btn.innerText = `INJECT (${cost} Bio)`;
        }
    } else { 
        btn.disabled = true; 
        if(selectedUnit.mutations.length>=2) btn.innerText = "Unit Full";
        else if(selectedDNA.length===0) btn.innerText = "Select DNA";
        else btn.innerText = "Need more Bio";
    }
}

function injectMutation() {
    let cost = 50 * selectedDNA.length;
    if(selectedUnit && selectedDNA.length > 0 && biomass >= cost) {
        let freeSlots = 2 - selectedUnit.mutations.length;
        if(selectedDNA.length <= freeSlots) {
            biomass -= cost;
            
            // Apply selected mutations
            selectedDNA.forEach(dna => {
                inventory[dna]--;
                selectedUnit.mutations.push(dna);
                selectedUnit.maxHp += 50; 
                selectedUnit.hp += 50;
            });
            
            // Clear selection logic if out of stock
            selectedDNA = selectedDNA.filter(d => inventory[d] > 0);
            
            renderInventory(); 
            updateInspector(); 
            createParticles(selectedUnit.x, selectedUnit.y, "#00ffaa", 20);
        }
    }
}

// -- STARTUP 10 PENGUINS --
for(let i=0; i<10; i++) {
    // Grid formation
    let col = i % 2;
    let row = Math.floor(i / 2);
    let px = 100 + col * 50;
    let py = 150 + row * 60;
    army.push(new Creature(px, py, 'blue'));
}

function loop() {
    if(isGameOver) return;
    
    ctx.clearRect(0,0,canvas.width,canvas.height); 
    drawBackground(); // DRAW THE NEW ICE TEXTURE
    
    gameTime++;

    if(gameTime % 60 === 0) biomass += 10;

    let spawnRate = 0.005; 
    if(enemies.length < 2 + (army.length/2) && Math.random() < spawnRate) {
        let type = MUTATION_KEYS[Math.floor(Math.random()*MUTATION_KEYS.length)];
        enemies.push(new Creature(canvas.width, Math.random()*canvas.height, 'red', [type]));
    }

    [...army, ...enemies].forEach(c => { c.update(); c.draw(); });
    
    for(let i=army.length-1; i>=0; i--) if(army[i].hp<=0) army.splice(i,1);
    
    for(let i=enemies.length-1; i>=0; i--) {
        if(enemies[i].hp<=0) {
            let e = enemies[i];
            let type = e.mutations[0]; if(type) spawnDNA(e.x, e.y, type);
            e.team = 'blue';
            e.hp = e.maxHp * 0.5; 
            e.vx = 0; e.vy = 0; 
            army.push(e); 
            createParticles(e.x, e.y, "pink", 15); 
            enemies.splice(i,1);
        }
    }

    for(let i=projectiles.length-1; i>=0; i--) { projectiles[i].update(); projectiles[i].draw(); if(projectiles[i].life<=0) projectiles.splice(i,1); }
    for(let i=items.length-1; i>=0; i--) {
        let it = items[i]; it.life--;
        ctx.fillStyle = MUTATIONS[it.type].color; ctx.beginPath(); 
        ctx.moveTo(it.x, it.y); ctx.lineTo(it.x-5, it.y-10); ctx.lineTo(it.x+5, it.y-10); ctx.fill(); 
        ctx.fillStyle="#004466"; ctx.font="10px Arial"; ctx.fillText("DNA", it.x-10, it.y+10);
        if(Math.hypot(mouseX-it.x, mouseY-it.y) < 35) { inventory[it.type]++; renderInventory(); biomass += 5; items.splice(i,1); }
        else if(it.life<=0) items.splice(i,1);
    }
    
    if(Math.random()<0.3) particles.push({x: Math.random()*canvas.width, y: 0, vx: (Math.random()-0.5), vy: Math.random()*2+1, c: 'white', life: 200});
    for(let i=particles.length-1; i>=0; i--) { let p = particles[i]; p.x+=p.vx; p.y+=p.vy; p.life--; ctx.globalAlpha=p.life/100; ctx.fillStyle=p.c; ctx.beginPath(); ctx.arc(p.x,p.y,Math.random()*2,0,Math.PI*2); ctx.fill(); if(p.life<=0) particles.splice(i,1); }
    ctx.globalAlpha=1;

    document.getElementById('bioDisplay').innerText = biomass;
    
    if(army.length === 0) { 
        isGameOver = true;
        document.getElementById('game-over-menu').style.display = 'flex';
    }
    else requestAnimationFrame(loop);
}

renderInventory();
loop();
</script>
</body>
</html>
