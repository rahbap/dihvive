<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Evolution Heroes: Ability Stealer</title>
    <style>
        body { margin: 0; background: #08080c; color: white; font-family: 'Segoe UI', sans-serif; overflow: hidden; user-select: none; }
        canvas { display: block; cursor: crosshair; }
        
        #hud {
            position: absolute; bottom: 0; left: 0; right: 0;
            background: rgba(0, 0, 0, 0.9); border-top: 1px solid #333;
            padding: 15px; display: flex; justify-content: center; gap: 20px;
            height: 60px; pointer-events: none;
        }

        #top-ui {
            position: absolute; top: 20px; left: 20px;
            pointer-events: none;
            background: rgba(0,0,0,0.6); padding: 15px; border-radius: 8px; border: 1px solid #444;
        }

        .legend { font-size: 12px; color: #aaa; margin-top: 5px; }
        .hero-count { color: gold; font-weight: bold; }
    </style>
</head>
<body>

    <div id="top-ui">
        <h2 style="margin:0; color: #00aaff;">EVOLUTION HEROES</h2>
        <div>Swarm Size: <span id="swarmSize">1</span></div>
        <div class="hero-count">Elite Heroes: <span id="heroSize">0</span></div>
        <div class="legend">
            - <b>Elite Enemies</b> have glowing rings.<br>
            - The unit that <b>KILLS</b> an Elite steals its power.<br>
            - Protect your Heroes!
        </div>
    </div>

    <canvas id="simCanvas"></canvas>

<script>
const canvas = document.getElementById('simCanvas');
const ctx = canvas.getContext('2d');
canvas.width = window.innerWidth;
canvas.height = window.innerHeight;

// -- GAME STATE --
let army = [];
let enemies = [];
let particles = [];
let projectiles = [];
let floatingTexts = [];
let mouseX = canvas.width/2, mouseY = canvas.height/2;

// The 10 Special Mutations
const ABILITIES = {
    NONE: 'none',
    LASER: 'laser',         // Shoots continuous beam
    BOMB: 'bomb',           // Explodes on death
    VAMPIRE: 'vampire',     // Heals on hit
    SHIELD: 'shield',       // Orbiting rock blocks damage
    FREEZE: 'freeze',       // Slows enemies
    SHOTGUN: 'shotgun',     // Shoots 3 bullets
    POISON: 'poison',       // Leaves trail of gas
    TELEPORT: 'teleport',   // Jumps to target
    LIGHTNING: 'lightning', // Arcs damage to neighbors
    BERSERK: 'berserk'      // 3x Attack speed, red glow
};

// Colors for abilities
const ABILITY_COLORS = {
    laser: '#ff0055',
    bomb: '#ffaa00',
    vampire: '#aa00ff',
    shield: '#00ffff',
    freeze: '#aaddff',
    shotgun: '#ffffff',
    poison: '#00ff00',
    teleport: '#ff00ff',
    lightning: '#ffff00',
    berserk: '#ff4444'
};

canvas.addEventListener('mousemove', e => { mouseX = e.clientX; mouseY = e.clientY; });

// -- CLASSES --

class Projectile {
    constructor(x, y, vx, vy, color, owner) {
        this.x = x; this.y = y;
        this.vx = vx; this.vy = vy;
        this.color = color;
        this.owner = owner;
        this.life = 60;
    }
    update() {
        this.x += this.vx; this.y += this.vy;
        this.life--;
    }
    draw() {
        ctx.fillStyle = this.color;
        ctx.beginPath(); ctx.arc(this.x, this.y, 4, 0, Math.PI*2); ctx.fill();
    }
}

class Creature {
    constructor(x, y, team, ability = 'none') {
        this.x = x;
        this.y = y;
        this.team = team;
        this.ability = ability;
        
        // Base Stats
        this.size = 12;
        this.speed = team === 'blue' ? 2.5 : 1.5;
        this.maxHp = 50;
        this.hp = 50;
        this.damage = 1;
        this.cooldown = 0;
        
        // Ability Specific Setup
        this.shieldAngle = 0;
        if (ability !== 'none') {
            this.maxHp = 150; // Elites are tougher
            this.hp = 150;
            this.size = 18;
        }

        this.angle = Math.random() * Math.PI * 2;
    }

    update() {
        // AI: Find Target
        let target = null;
        let minDist = 1000;
        let pool = this.team === 'blue' ? enemies : army;

        for(let e of pool) {
            let d = Math.hypot(e.x - this.x, e.y - this.y);
            if (d < minDist) { minDist = d; target = e; }
        }

        // Movement Logic
        if (target) {
            if (this.ability === 'teleport' && Math.random() < 0.02 && minDist > 100) {
                // Teleport Logic
                this.x = target.x + (Math.random()*60-30);
                this.y = target.y + (Math.random()*60-30);
                createParticles(this.x, this.y, "#ff00ff", 10);
            } else {
                // Normal Move
                let dx = target.x - this.x;
                let dy = target.y - this.y;
                this.angle = Math.atan2(dy, dx);
                
                // Stop if close enough to shoot (for ranged)
                let stopDist = (this.ability === 'shotgun' || this.ability === 'laser') ? 150 : 0;
                
                if (minDist > this.size + target.size + stopDist) {
                    this.x += Math.cos(this.angle) * this.speed;
                    this.y += Math.sin(this.angle) * this.speed;
                }
            }
            
            // Attack Logic
            this.handleCombat(target, minDist);

        } else if (this.team === 'blue') {
            // Idle blue moves to mouse
            let dx = mouseX - this.x;
            let dy = mouseY - this.y;
            if (Math.hypot(dx, dy) > 100) {
                this.angle = Math.atan2(dy, dx);
                this.x += Math.cos(this.angle) * this.speed;
                this.y += Math.sin(this.angle) * this.speed;
            }
        }

        // Poison Trail Logic
        if (this.ability === 'poison' && this.cooldown % 10 === 0) {
            createParticles(this.x, this.y, "rgba(0,255,0,0.5)", 1); // Gas cloud visual
        }
        
        // Cooldown tick
        if (this.cooldown > 0) this.cooldown--;
        
        // Shield Rotation
        if (this.ability === 'shield') this.shieldAngle += 0.1;

        // Bounds
        if(this.x < 0) this.x = 0; if(this.x > canvas.width) this.x = canvas.width;
        if(this.y < 0) this.y = 0; if(this.y > canvas.height) this.y = canvas.height;
    }

    handleCombat(target, dist) {
        if (this.cooldown > 0) return;

        // 1. Ranged Abilities
        if (this.ability === 'laser' && dist < 200) {
            // Laser is instant hit
            ctx.strokeStyle = "red";
            ctx.lineWidth = 3;
            ctx.beginPath(); ctx.moveTo(this.x, this.y); ctx.lineTo(target.x, target.y); ctx.stroke();
            this.dealDamage(target, 0.5); // Fast tick damage
            return; // No cooldown on continuous laser, just low dmg
        }

        if (this.ability === 'shotgun' && dist < 200) {
            for(let i=-1; i<=1; i++) {
                let a = this.angle + (i * 0.3);
                projectiles.push(new Projectile(this.x, this.y, Math.cos(a)*6, Math.sin(a)*6, "white", this));
            }
            this.cooldown = 60;
            return;
        }

        if (this.ability === 'lightning' && dist < 150) {
            // Hit target and 2 neighbors
            this.dealDamage(target, 5);
            this.drawLightning(target);
            // Chain
            let bounces = 0;
            let pool = this.team === 'blue' ? enemies : army;
            for(let n of pool) {
                if (n !== target && Math.hypot(n.x - target.x, n.y - target.y) < 100 && bounces < 2) {
                    this.dealDamage(n, 3);
                    this.drawLightning(target, n);
                    bounces++;
                }
            }
            this.cooldown = 40;
            return;
        }

        // 2. Melee Combat
        if (dist < this.size + target.size + 5) {
            let dmg = this.damage * 5;
            
            if (this.ability === 'berserk') {
                dmg *= 2; 
                this.cooldown = 10; // Very fast attack
            } else {
                this.cooldown = 30;
            }

            if (this.ability === 'vampire') {
                this.hp = Math.min(this.hp + 2, this.maxHp);
                createParticles(this.x, this.y, "purple", 2);
            }

            if (this.ability === 'freeze') {
                target.speed = 0.2; // Slow down
                setTimeout(() => { if(target) target.speed = (target.team==='blue'?2.5:1.5); }, 2000);
            }

            this.dealDamage(target, dmg);
        }
    }

    dealDamage(target, amount) {
        // Shield Logic: 30% chance to block damage completely if Shielded
        if (target.ability === 'shield' && Math.random() < 0.3) {
            createParticles(target.x, target.y, "cyan", 3); // Spark off shield
            return;
        }

        target.hp -= amount;
        
        // Kill Logic
        if (target.hp <= 0) {
            // CHECK FOR ABILITY THEFT
            if (this.team === 'blue' && target.ability !== 'none' && this.ability === 'none') {
                this.ability = target.ability;
                this.maxHp = 200; // Hero buff
                this.hp = 200;
                this.size = 20;
                spawnFloatingText(this.x, this.y, `STOLE ${this.ability.toUpperCase()}!`, "gold");
                createParticles(this.x, this.y, "gold", 20);
            } else {
                // Regular kill assimilation (spawn new weak unit)
                if (this.team === 'blue') {
                    let recruit = new Creature(target.x, target.y, 'blue');
                    army.push(recruit);
                }
            }
            
            // Bomb Logic on Death
            if (target.ability === 'bomb') {
                createExplosion(target.x, target.y, 100, "orange");
                // Damage nearby
                let enemiesOfBomb = target.team === 'blue' ? enemies : army;
                enemiesOfBomb.forEach(e => {
                    if (Math.hypot(e.x - target.x, e.y - target.y) < 100) e.hp -= 50;
                });
            }

            // Remove dead entity
            if (target.team === 'blue') {
                army = army.filter(u => u !== target);
            } else {
                enemies = enemies.filter(u => u !== target);
            }
            
            createParticles(target.x, target.y, target.team === 'red'?'red':'blue', 5);
        }
    }

    drawLightning(start, end=null) {
        ctx.strokeStyle = "yellow";
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(this.x, this.y);
        if(end) { ctx.moveTo(start.x, start.y); ctx.lineTo(end.x, end.y); }
        else { ctx.lineTo(start.x, start.y); }
        ctx.stroke();
    }

    draw() {
        ctx.save();
        ctx.translate(this.x, this.y);

        // -- ABILITY VISUALS --
        if (this.ability !== 'none') {
            // Glow
            ctx.shadowBlur = 15;
            ctx.shadowColor = ABILITY_COLORS[this.ability];
            
            // Shield Ring
            if (this.ability === 'shield') {
                ctx.strokeStyle = "cyan";
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.arc(0, 0, this.size + 10, this.shieldAngle, this.shieldAngle + Math.PI);
                ctx.stroke();
            }
        }

        // Body
        ctx.fillStyle = this.team === 'blue' ? '#00aaff' : '#ff4444';
        if (this.ability !== 'none') ctx.fillStyle = ABILITY_COLORS[this.ability];
        
        ctx.beginPath();
        ctx.arc(0, 0, this.size, 0, Math.PI*2);
        ctx.fill();
        ctx.shadowBlur = 0; // Reset glow

        // Nucleus
        ctx.fillStyle = "rgba(0,0,0,0.5)";
        ctx.beginPath(); ctx.arc(0, 0, this.size*0.4, 0, Math.PI*2); ctx.fill();

        // Bomb fuse visual
        if (this.ability === 'bomb') {
            ctx.fillStyle = "red";
            ctx.font = "10px Arial";
            ctx.fillText("ðŸ’£", -5, 4);
        }

        ctx.restore();
    }
}

// -- SYSTEMS --

function createParticles(x, y, color, count) {
    for(let i=0; i<count; i++) {
        particles.push({x, y, vx: (Math.random()-0.5)*5, vy: (Math.random()-0.5)*5, life: 1, color});
    }
}

function createExplosion(x, y, radius, color) {
    ctx.beginPath();
    ctx.arc(x, y, radius, 0, Math.PI*2);
    ctx.fillStyle = "rgba(255, 100, 0, 0.5)";
    ctx.fill();
    createParticles(x, y, color, 20);
}

function spawnFloatingText(x, y, text, color) {
    floatingTexts.push({x, y, text, color, life: 1.5});
}

function spawnEnemy() {
    // 20% Chance for Elite Enemy
    let ability = 'none';
    if (Math.random() < 0.2) {
        let keys = Object.keys(ABILITIES);
        let key = keys[ Math.floor(Math.random() * (keys.length - 1)) + 1 ]; // Skip NONE
        ability = ABILITIES[key];
    }

    let ex, ey;
    do {
        ex = Math.random() * canvas.width;
        ey = Math.random() * canvas.height;
    } while (Math.hypot(ex - mouseX, ey - mouseY) < 400);

    enemies.push(new Creature(ex, ey, 'red', ability));
}

// -- MAIN LOOP --
army.push(new Creature(canvas.width/2, canvas.height/2, 'blue')); // Start with 1
army.push(new Creature(canvas.width/2+20, canvas.height/2, 'blue')); // Start with 2

function loop() {
    ctx.fillStyle = "#08080c";
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    // Spawning
    if (enemies.length < 5 + (army.length/2)) {
        if (Math.random() < 0.05) spawnEnemy();
    }

    // Projectiles
    for (let i = projectiles.length - 1; i >= 0; i--) {
        let p = projectiles[i];
        p.update();
        p.draw();
        
        // Collision
        let targets = p.owner.team === 'blue' ? enemies : army;
        for (let t of targets) {
            if (Math.hypot(t.x - p.x, t.y - p.y) < t.size + 5) {
                p.owner.dealDamage(t, 10);
                projectiles.splice(i, 1);
                break;
            }
        }
        if (p.life <= 0) projectiles.splice(i, 1);
    }

    // Creatures
    [...army, ...enemies].forEach(c => {
        c.update();
        c.draw();
    });

    // Particles
    for (let i = particles.length - 1; i >= 0; i--) {
        let p = particles[i];
        p.x += p.vx; p.y += p.vy; p.life -= 0.05;
        ctx.globalAlpha = p.life; ctx.fillStyle = p.color;
        ctx.beginPath(); ctx.arc(p.x, p.y, 2, 0, Math.PI*2); ctx.fill();
        ctx.globalAlpha = 1;
        if(p.life <= 0) particles.splice(i, 1);
    }

    // Floating Text
    for (let i = floatingTexts.length - 1; i >= 0; i--) {
        let ft = floatingTexts[i];
        ft.y -= 1; ft.life -= 0.02;
        ctx.fillStyle = ft.color; ctx.globalAlpha = ft.life;
        ctx.font = "bold 14px Arial"; ctx.fillText(ft.text, ft.x, ft.y);
        ctx.globalAlpha = 1;
        if(ft.life <= 0) floatingTexts.splice(i, 1);
    }

    // UI
    document.getElementById('swarmSize').innerText = army.length;
    document.getElementById('heroSize').innerText = army.filter(u => u.ability !== 'none').length;

    // Game Over
    if (army.length === 0) {
        ctx.fillStyle = "white"; ctx.font = "40px Arial";
        ctx.fillText("GAME OVER", canvas.width/2 - 100, canvas.height/2);
        if (canvas.onclick == null) canvas.onclick = () => location.reload();
    } else {
        requestAnimationFrame(loop);
    }
}

loop();
</script>
</body>
</html>
