<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Penguin Evolution: Mutant Lab</title>
    <style>
        body { margin: 0; background: #cceeff; color: #004466; font-family: 'Segoe UI', sans-serif; overflow: hidden; user-select: none; }
        
        /* ICE BACKGROUND */
        canvas { 
            display: block; cursor: crosshair; margin-right: 280px; 
            background: radial-gradient(circle, #f0faff 0%, #b3e0ff 100%);
        }
        
        /* UI PANEL */
        #lab-panel {
            position: absolute; right: 0; top: 0; bottom: 0; width: 280px;
            background: linear-gradient(to bottom, #1a2a3a, #0d1520); 
            border-left: 4px solid #55aaff;
            padding: 15px; display: flex; flex-direction: column;
            color: white;
            box-shadow: -5px 0 20px rgba(0, 0, 0, 0.5);
        }

        h2 { color: #55aaff; margin: 0 0 10px 0; font-size: 20px; text-transform: uppercase; border-bottom: 1px solid #335577; padding-bottom: 5px; }
        .resource { font-size: 24px; color: #00ffaa; font-weight: bold; margin-bottom: 5px; }
        .sub-res { font-size: 12px; color: #88ccaa; margin-bottom: 15px; }
        
        #dna-inventory {
            flex-grow: 1; overflow-y: auto; display: flex; flex-direction: column; gap: 6px;
            margin-bottom: 10px; padding-right: 5px;
        }

        /* CUSTOM SCROLLBAR */
        #dna-inventory::-webkit-scrollbar { width: 6px; }
        #dna-inventory::-webkit-scrollbar-thumb { background: #335577; border-radius: 3px; }

        .dna-item {
            background: #253545; padding: 10px; border-radius: 6px; cursor: pointer;
            display: flex; justify-content: space-between; align-items: center;
            border: 1px solid #334455; transition: 0.2s;
        }
        .dna-item:hover { background: #304050; border-color: #55aaff; transform: translateX(-2px); }
        .dna-item.selected { border-color: #00ffaa; background: #1a3a4a; box-shadow: 0 0 10px rgba(0,255,170,0.2); }
        
        #unit-inspector {
            height: 220px; background: #101820; border-radius: 8px; padding: 15px;
            border: 1px solid #335577; display: none; flex-direction: column;
        }
        .slot {
            background: #000; height: 35px; margin: 5px 0; border: 1px dashed #446688; border-radius: 4px;
            display: flex; align-items: center; justify-content: center; font-size: 13px; color: #6688aa;
        }
        .slot.filled { border: 1px solid #55aaff; color: #fff; background: #003344; font-weight: bold; text-shadow: 0 0 5px #00aaff; }

        button {
            background: #55aaff; color: #002233; border: none; padding: 12px;
            font-weight: bold; cursor: pointer; margin-top: auto; border-radius: 6px;
            text-transform: uppercase; letter-spacing: 1px; transition: 0.2s;
        }
        button:hover:not(:disabled) { background: #88ccff; box-shadow: 0 0 15px #55aaff; }
        button:disabled { background: #334455; color: #556677; cursor: not-allowed; }
        
        #msg-overlay {
            position: absolute; top: 20px; left: 20px; pointer-events: none;
            background: rgba(255,255,255,0.7); padding: 15px; border-radius: 10px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.1); border: 2px solid #fff;
            color: #003344;
        }
    </style>
</head>
<body>

    <div id="msg-overlay">
        <h3 style="margin:0; color:#006699">üêß PENGUIN LABS</h3>
        <div>1. You have <b>Free DNA</b> in your list!</div>
        <div>2. Click a Blue Penguin -> Select DNA -> <b>Inject</b>.</div>
        <div>3. You get <b>+5 Biomass</b> automatically every second.</div>
        <div style="color:#cc0000; margin-top:5px; font-weight:bold;">Defend the Ice Shelf!</div>
    </div>

    <div id="lab-panel">
        <h2>Biomass</h2>
        <div id="bioDisplay" class="resource">500</div>
        <div class="sub-res">+5 generated / sec</div>
        
        <h2>DNA Freezer</h2>
        <div id="dna-inventory"></div>

        <div id="unit-inspector">
            <h3 style="margin:0; font-size:14px; color:#55aaff; border-bottom:1px solid #333; padding-bottom:5px;">Penguin Modding</h3>
            <div class="slot" id="slot1">Empty Gene Slot</div>
            <div class="slot" id="slot2">Empty Gene Slot</div>
            <button id="btnInject" onclick="injectMutation()">INJECT GENE</button>
        </div>
    </div>

    <canvas id="simCanvas"></canvas>

<script>
const canvas = document.getElementById('simCanvas');
const ctx = canvas.getContext('2d');
canvas.width = window.innerWidth - 280; 
canvas.height = window.innerHeight;

// -- CONFIG --
const MUTATIONS = {
    LASER: { name: 'Laser Eyes', color: '#ff0055', type: 'range' },
    SHOTGUN: { name: 'Snow Blaster', color: '#ffffff', type: 'range' },
    SNIPER: { name: 'Icicle Sniper', color: '#00ff00', type: 'range' },
    MISSILE: { name: 'Fish Missile', color: '#ffaa00', type: 'range' },
    SPIKES: { name: 'Spiked Armor', color: '#555555', type: 'melee' },
    SAW: { name: 'Buzz Saw', color: '#cccccc', type: 'melee' },
    SHIELD: { name: 'Bubble Shield', color: '#00ffff', type: 'tank' },
    HEALER: { name: 'Medic Aura', color: '#00ffaa', type: 'support' },
    TESLA: { name: 'Shock Coil', color: '#ffff00', type: 'melee' },
    REPULSE: { name: 'Wind Blower', color: '#ff00ff', type: 'tank' },
    NUKE: { name: 'Nuke', color: '#33ff00', type: 'tank' },
    GRAVITY: { name: 'Vacuum', color: '#220044', type: 'support' },
    BLINK: { name: 'Teleporter', color: '#aa00ff', type: 'melee' },
    FLAME: { name: 'Flamethrower', color: '#ff4400', type: 'range' }
};

const MUTATION_KEYS = Object.keys(MUTATIONS);

// -- GAME STATE --
let biomass = 500; // SUPER EASY START
let gameTime = 0;
let army = [];
let enemies = [];
let items = []; 
let projectiles = [];
let particles = [];
let inventory = {}; 
let selectedUnit = null;
let selectedDNA = null;

// Initialize Inventory
MUTATION_KEYS.forEach(k => inventory[k] = 0);

// STARTER PACK (FREE ITEMS)
inventory['LASER'] = 1;
inventory['SPIKES'] = 1;
inventory['SHIELD'] = 1;
inventory['SHOTGUN'] = 1;

// -- INPUTS --
let mouseX = 0, mouseY = 0;
canvas.addEventListener('mousemove', e => { mouseX = e.clientX; mouseY = e.clientY; });
canvas.addEventListener('mousedown', e => {
    let clicked = false;
    for(let u of army) {
        if(Math.hypot(u.x - mouseX, u.y - mouseY) < u.size + 15) {
            selectUnit(u);
            clicked = true;
            break;
        }
    }
    if(!clicked) deselectUnit();
});

// -- PENGUIN DRAWING FUNCTION --
function drawPenguin(ctx, x, y, size, angle, team, waddle, hpPerc, mutations) {
    ctx.save();
    ctx.translate(x, y);
    ctx.rotate(angle); // Face direction
    
    // Waddle Animation (Rotate body slightly based on movement)
    ctx.rotate(Math.sin(waddle) * 0.2);

    // 1. FEET
    ctx.fillStyle = "#ffaa00";
    ctx.beginPath(); ctx.ellipse(5, 5, 5, 3, 0, 0, Math.PI*2); ctx.fill(); // Right foot
    ctx.beginPath(); ctx.ellipse(5, -5, 5, 3, 0, 0, Math.PI*2); ctx.fill(); // Left foot

    // 2. MUTATIONS (UNDER)
    mutations.forEach(m => drawMutation(ctx, m, true, size));

    // 3. BODY
    // Team colors: Blue = Player, Red = Enemy
    let bodyColor = team === 'blue' ? '#0077aa' : '#aa3333';
    if(team === 'red') bodyColor = '#cc4444'; // Redder for bad penguins
    
    // Highlight if selected
    if(selectedUnit && selectedUnit.x === x && selectedUnit.y === y) {
        ctx.shadowBlur = 15; ctx.shadowColor = "#00ffaa";
    }

    ctx.fillStyle = bodyColor;
    // Egg shape for body
    ctx.beginPath();
    ctx.ellipse(0, 0, size * 1.2, size, 0, 0, Math.PI*2);
    ctx.fill();
    ctx.shadowBlur = 0;

    // 4. BELLY (White)
    ctx.fillStyle = "white";
    ctx.beginPath();
    ctx.ellipse(2, 0, size * 0.9, size * 0.7, 0, 0, Math.PI*2);
    ctx.fill();

    // 5. EYES
    ctx.fillStyle = "black";
    ctx.beginPath(); ctx.arc(6, -4, 2, 0, Math.PI*2); ctx.fill(); // Left
    ctx.beginPath(); ctx.arc(6, 4, 2, 0, Math.PI*2); ctx.fill(); // Right
    ctx.fillStyle = "white"; // Eye shine
    ctx.beginPath(); ctx.arc(7, -5, 0.5, 0, Math.PI*2); ctx.fill();
    ctx.beginPath(); ctx.arc(7, 3, 0.5, 0, Math.PI*2); ctx.fill();
    
    // Angry eyebrows for enemies
    if(team === 'red') {
        ctx.strokeStyle = "black"; ctx.lineWidth = 1;
        ctx.beginPath(); ctx.moveTo(4, -7); ctx.lineTo(8, -2); ctx.stroke();
        ctx.beginPath(); ctx.moveTo(4, 7); ctx.lineTo(8, 2); ctx.stroke();
    }

    // 6. BEAK
    ctx.fillStyle = "#ffaa00";
    ctx.beginPath();
    ctx.moveTo(10, -2);
    ctx.lineTo(18, 0);
    ctx.lineTo(10, 2);
    ctx.fill();

    // 7. WINGS (Flippers)
    ctx.fillStyle = bodyColor;
    ctx.beginPath(); ctx.ellipse(-5, -size, 8, 3, Math.PI/4, 0, Math.PI*2); ctx.fill();
    ctx.beginPath(); ctx.ellipse(-5, size, 8, 3, -Math.PI/4, 0, Math.PI*2); ctx.fill();

    // 8. MUTATIONS (OVER)
    mutations.forEach(m => drawMutation(ctx, m, false, size));

    // 9. HP BAR
    ctx.rotate(-Math.sin(waddle) * 0.2); // Undo waddle for bar
    ctx.rotate(-angle); // Undo rotation for bar so it stays flat
    ctx.fillStyle = "rgba(0,0,0,0.5)"; ctx.fillRect(-15, -25, 30, 6);
    ctx.fillStyle = hpPerc > 0.5 ? "#00ff00" : "#ff0000"; 
    ctx.fillRect(-14, -24, 28 * hpPerc, 4);

    ctx.restore();
}

function drawMutation(ctx, key, isUnder, size) {
    if(isUnder) {
        if(key === 'SPIKES') { ctx.fillStyle = "#555"; for(let i=0; i<6; i++) { ctx.rotate(1); ctx.beginPath(); ctx.moveTo(size, -3); ctx.lineTo(size+8, 0); ctx.lineTo(size, 3); ctx.fill(); } }
        if(key === 'SAW') { ctx.rotate(Date.now()/100); ctx.fillStyle = "#bbb"; ctx.beginPath(); for(let i=0; i<8; i++) { ctx.rotate(Math.PI/4); ctx.lineTo(size+12, 0); ctx.lineTo(size+4, 4); } ctx.fill(); }
        if(key === 'SHIELD') { ctx.strokeStyle = "rgba(0,255,255,0.6)"; ctx.lineWidth = 3; ctx.beginPath(); ctx.arc(0,0, size+10, 0, Math.PI*2); ctx.stroke(); }
        if(key === 'REPULSE') { ctx.strokeStyle = "magenta"; ctx.lineWidth=2; ctx.beginPath(); ctx.arc(0,0,size+5, 0, Math.PI*2); ctx.stroke(); }
        if(key === 'HEALER') { ctx.fillStyle = "rgba(0,255,100,0.2)"; ctx.beginPath(); ctx.arc(0,0, 60, 0, Math.PI*2); ctx.fill(); }
    } else {
        // Weapons mount on the side/back
        if(key === 'LASER') { ctx.fillStyle = "#333"; ctx.fillRect(-5, -18, 15, 6); ctx.fillStyle="red"; ctx.fillRect(10, -17, 2, 4); }
        if(key === 'SNIPER') { ctx.fillStyle = "#222"; ctx.fillRect(-5, -18, 25, 4); ctx.fillStyle="#0f0"; ctx.fillRect(20, -18, 4, 4); }
        if(key === 'SHOTGUN') { ctx.fillStyle = "#444"; ctx.fillRect(-5, -18, 12, 8); }
        if(key === 'FLAME') { ctx.fillStyle = "darkred"; ctx.fillRect(-5, -18, 14, 8); ctx.fillStyle="orange"; ctx.beginPath(); ctx.arc(9,-14,3,0,Math.PI*2); ctx.fill(); }
        if(key === 'MISSILE') { ctx.fillStyle = "#666"; ctx.fillRect(-5, -20, 10, 8); ctx.fillStyle="orange"; ctx.beginPath(); ctx.moveTo(5,-20); ctx.lineTo(12,-16); ctx.lineTo(5,-12); ctx.fill(); }
        if(key === 'TESLA') { ctx.fillStyle = "yellow"; ctx.beginPath(); ctx.arc(0,-15, 5, 0, Math.PI*2); ctx.fill(); }
        if(key === 'BOMB' || key === 'NUKE') { ctx.fillStyle = "black"; ctx.font = "16px Arial"; ctx.fillText("‚ò¢Ô∏è", -8, -15); }
    }
}

// -- CLASS --
class Creature {
    constructor(x, y, team, mutations = []) {
        this.id = Math.floor(Math.random()*10000);
        this.x = x; this.y = y;
        this.vx = 0; this.vy = 0;
        this.team = team;
        this.mutations = [...mutations];
        
        this.hp = 100; this.maxHp = 100;
        this.size = 14; // Bigger for penguin
        this.friction = 0.96; // SLIPPERY ICE PHYSICS (0.96 is more slippery than 0.90)
        this.accel = 0.25; 
        this.waddleOffset = Math.random() * 100; // Animation offset
        
        this.cooldowns = { slot0: 0, slot1: 0, melee: 0 };
        
        if(this.mutations.length > 0) {
            this.maxHp += 50 * this.mutations.length;
            this.hp = this.maxHp;
        }
    }

    isRanged() { return this.mutations.some(m => MUTATIONS[m].type === 'range'); }

    update() {
        this.vx *= this.friction;
        this.vy *= this.friction;

        let target = this.findTarget();

        if (target) {
            let dx = target.x - this.x;
            let dy = target.y - this.y;
            let dist = Math.hypot(dx, dy);
            let angleToTarget = Math.atan2(dy, dx);
            this.angle = angleToTarget;

            if (this.isRanged()) {
                let optimal = 200;
                if (dist > optimal) {
                    this.vx += Math.cos(angleToTarget) * this.accel;
                    this.vy += Math.sin(angleToTarget) * this.accel;
                } else if (dist < optimal - 50) {
                    this.vx -= Math.cos(angleToTarget) * (this.accel * 0.8);
                    this.vy -= Math.sin(angleToTarget) * (this.accel * 0.8);
                }
            } else {
                // Melee Lunge
                if (dist < 120 && this.cooldowns.melee <= 0) {
                    this.vx += Math.cos(angleToTarget) * 5; 
                    this.vy += Math.sin(angleToTarget) * 5;
                    this.cooldowns.melee = 50; 
                    createParticles(this.x, this.y, "white", 3); // Snow kick
                } else {
                    this.vx += Math.cos(angleToTarget) * this.accel;
                    this.vy += Math.sin(angleToTarget) * this.accel;
                }
            }

            // Abilities
            this.mutations.forEach((mut, index) => {
                let cdKey = 'slot'+index;
                if(this.cooldowns[cdKey] <= 0) this.useAbility(mut, target, dist, cdKey);
            });

            // Collision
            if(dist < this.size + target.size) {
                let dmg = 2;
                let impact = Math.hypot(this.vx, this.vy);
                if (impact > 2) dmg = 8;
                if (this.mutations.includes('SPIKES')) dmg += 10;
                if (this.mutations.includes('SAW')) dmg += 5;
                if (this.mutations.includes('TESLA')) dmg += 3;
                
                target.takeDamage(dmg);

                // Bounce
                let pushForce = 4; // High bounce on ice
                let pushDir = Math.atan2(this.y - target.y, this.x - target.x);
                this.vx = Math.cos(pushDir) * pushForce;
                this.vy = Math.sin(pushDir) * pushForce;
                target.vx = Math.cos(pushDir + Math.PI) * pushForce;
                target.vy = Math.sin(pushDir + Math.PI) * pushForce;
            }
        } else if (this.team === 'blue') {
            // Idle wander
            if(Math.hypot(mouseX-this.x, mouseY-this.y) > 100) {
                let a = Math.atan2(mouseY-this.y, mouseX-this.x);
                this.vx += Math.cos(a) * (this.accel * 0.5);
                this.vy += Math.sin(a) * (this.accel * 0.5);
                this.angle = a;
            }
        }

        // Separation
        let pool = this.team === 'blue' ? army : enemies;
        for(let other of pool) {
            if (other !== this) {
                let dx = this.x - other.x;
                let dy = this.y - other.y;
                let dist = Math.hypot(dx, dy);
                if (dist < this.size*2 && dist > 0) {
                    let push = (this.size*2 - dist) / 5;
                    let angle = Math.atan2(dy, dx);
                    this.vx += Math.cos(angle) * push * 0.1;
                    this.vy += Math.sin(angle) * push * 0.1;
                }
            }
        }

        this.x += this.vx;
        this.y += this.vy;

        // Bounds bounce
        if(this.x<0 || this.x>canvas.width) this.vx *= -1;
        if(this.y<0 || this.y>canvas.height) this.vy *= -1;
        this.x = Math.max(10, Math.min(canvas.width-10, this.x));
        this.y = Math.max(10, Math.min(canvas.height-10, this.y));

        if(this.cooldowns.slot0 > 0) this.cooldowns.slot0--;
        if(this.cooldowns.slot1 > 0) this.cooldowns.slot1--;
        if(this.cooldowns.melee > 0) this.cooldowns.melee--;
    }

    draw() {
        // Calculate waddle
        let speed = Math.hypot(this.vx, this.vy);
        let waddle = speed > 0.1 ? Math.sin((gameTime + this.waddleOffset) * 0.3) * 0.3 : 0;
        
        drawPenguin(ctx, this.x, this.y, this.size, this.angle, this.team, waddle, this.hp/this.maxHp, this.mutations);
    }

    findTarget() {
        let pool = this.team === 'blue' ? enemies : army;
        let best = null, minDist = 9999;
        for(let e of pool) {
            let d = Math.hypot(e.x - this.x, e.y - this.y);
            if(d < minDist) { minDist = d; best = e; }
        }
        return best;
    }

    useAbility(key, target, dist, cdKey) {
        if(key === 'LASER' && dist < 300) { spawnProj(this, target, 'LASER'); this.cooldowns[cdKey] = 40; }
        if(key === 'SHOTGUN' && dist < 200) { for(let i=-0.3; i<=0.3; i+=0.3) spawnProj(this, target, 'SHOTGUN', i); this.cooldowns[cdKey] = 60; }
        if(key === 'SNIPER' && dist < 600) { spawnProj(this, target, 'SNIPER'); this.cooldowns[cdKey] = 120; }
        if(key === 'FLAME' && dist < 120) { spawnProj(this, target, 'FLAME'); this.cooldowns[cdKey] = 5; }
        if(key === 'MISSILE' && dist < 450) { spawnProj(this, target, 'MISSILE'); this.cooldowns[cdKey] = 100; }
        
        if(key === 'BLINK' && dist > 150) {
            this.x = target.x + (Math.random()*60-30);
            this.y = target.y + (Math.random()*60-30);
            createParticles(this.x, this.y, "#aa00ff", 10);
            this.cooldowns[cdKey] = 100;
        }
        if(key === 'TESLA' && dist < 120) {
            drawLightning(this.x, this.y, target.x, target.y);
            target.takeDamage(10);
            this.cooldowns[cdKey] = 40;
        }
        if(key === 'REPULSE' && dist < 80) {
             let a = Math.atan2(target.y - this.y, target.x - this.x);
             target.vx += Math.cos(a) * 12;
             target.vy += Math.sin(a) * 12;
             this.cooldowns[cdKey] = 30;
        }
        if(key === 'HEALER') {
            let mates = this.team === 'blue' ? army : enemies;
            mates.forEach(m => {
                if(m !== this && Math.hypot(m.x-this.x, m.y-this.y) < 100) m.hp = Math.min(m.hp + 0.3, m.maxHp);
            });
        }
    }

    takeDamage(amt) {
        if(this.mutations.includes('SHIELD') && Math.random() < 0.3) {
            createParticles(this.x, this.y, "cyan", 2);
            return;
        }
        this.hp -= amt;
        if(this.hp <= 0) {
            // Death Effects
            if(this.mutations.includes('BOMB') || this.mutations.includes('NUKE')) {
                createExplosion(this.x, this.y, 150, "orange");
                let targets = this.team === 'blue' ? enemies : army;
                targets.forEach(t => {
                    if(Math.hypot(t.x-this.x, t.y-this.y) < 150) {
                        t.takeDamage(50);
                        let a = Math.atan2(t.y-this.y, t.x-this.x);
                        t.vx += Math.cos(a)*15; t.vy += Math.sin(a)*15;
                    }
                });
            }
            createParticles(this.x, this.y, "red", 10);
        }
    }
}

// -- PROJECTILES --
class Projectile {
    constructor(owner, target, type, angleOffset = 0) {
        this.x = owner.x; this.y = owner.y;
        this.type = type; this.owner = owner;
        let a = Math.atan2(target.y - owner.y, target.x - owner.x) + angleOffset;
        this.vx = Math.cos(a); this.vy = Math.sin(a);
        this.target = target;
        
        let stats = {
            LASER: { spd: 8, life: 60, color: 'red', w: 3 },
            SNIPER: { spd: 15, life: 60, color: '#0f0', w: 2 },
            SHOTGUN: { spd: 6, life: 25, color: 'white', w: 4 },
            FLAME: { spd: 4, life: 20, color: 'orange', w: 6 },
            MISSILE: { spd: 3, life: 150, color: 'orange', w: 6 }
        };
        this.props = stats[type] || stats.LASER;
        this.vx *= this.props.spd; this.vy *= this.props.spd;
        this.life = this.props.life;
    }
    update() {
        if(this.type === 'MISSILE' && this.target && this.target.hp>0) {
            let a = Math.atan2(this.target.y-this.y, this.target.x-this.x);
            this.vx = Math.cos(a)*this.props.spd; this.vy = Math.sin(a)*this.props.spd;
        }
        this.x += this.vx; this.y += this.vy; this.life--;
        
        let pool = this.owner.team === 'blue' ? enemies : army;
        for(let t of pool) {
            if(Math.hypot(t.x-this.x, t.y-this.y) < t.size + 10) {
                let dmg = 10;
                if(this.type==='SNIPER') dmg = 40;
                if(this.type==='SHOTGUN') { dmg = 8; t.vx += this.vx*0.5; t.vy += this.vy*0.5; }
                if(this.type==='FLAME') dmg = 2;
                if(this.type==='MISSILE') { dmg=30; createExplosion(this.x,this.y, 40, "orange"); }
                t.takeDamage(dmg);
                this.life = 0; break;
            }
        }
    }
    draw() { ctx.fillStyle = this.props.color; ctx.beginPath(); ctx.arc(this.x, this.y, this.props.w, 0, Math.PI*2); ctx.fill(); }
}

// -- SYSTEMS --
function spawnDNA(x, y, type) { items.push({x, y, type, life: 1000}); }
function spawnProj(o, t, type, off=0) { projectiles.push(new Projectile(o, t, type, off)); }
function drawLightning(x1,y1,x2,y2) { ctx.strokeStyle="yellow"; ctx.beginPath(); ctx.moveTo(x1,y1); ctx.lineTo((x1+x2)/2+(Math.random()*20-10), (y1+y2)/2+(Math.random()*20-10)); ctx.lineTo(x2,y2); ctx.stroke(); }
function createExplosion(x,y,r,c) { ctx.fillStyle=c; ctx.globalAlpha=0.5; ctx.beginPath(); ctx.arc(x,y,r,0,Math.PI*2); ctx.fill(); ctx.globalAlpha=1; }
function createParticles(x,y,c,n) { for(let i=0; i<n; i++) particles.push({x,y,vx:(Math.random()-0.5)*5, vy:(Math.random()-0.5)*5,c,life:1}); }

// -- UI --
function renderInventory() {
    const div = document.getElementById('dna-inventory'); div.innerHTML = "";
    MUTATION_KEYS.forEach(k => {
        if(inventory[k] > 0) {
            let el = document.createElement('div'); el.className = "dna-item" + (selectedDNA===k?" selected":"");
            el.innerHTML = `<span style="color:${MUTATIONS[k].color}">${MUTATIONS[k].name}</span> <span>x${inventory[k]}</span>`;
            el.onclick = () => { selectedDNA = k; renderInventory(); updateInspector(); };
            div.appendChild(el);
        }
    });
}
function selectUnit(u) { selectedUnit = u; document.getElementById('unit-inspector').style.display='flex'; updateInspector(); }
function deselectUnit() { selectedUnit = null; document.getElementById('unit-inspector').style.display='none'; }
function updateInspector() {
    if(!selectedUnit) return;
    let slots = [document.getElementById('slot1'), document.getElementById('slot2')];
    selectedUnit.mutations.forEach((m, i) => { if(i<2) { slots[i].className="slot filled"; slots[i].style.color=MUTATIONS[m].color; slots[i].innerText=MUTATIONS[m].name; } });
    if(selectedUnit.mutations.length<1) { slots[0].innerText = "Empty Slot"; slots[0].className="slot"; }
    if(selectedUnit.mutations.length<2) { slots[1].innerText = "Empty Slot"; slots[1].className="slot"; }
    let btn = document.getElementById('btnInject');
    if(selectedUnit.mutations.length < 2 && selectedDNA && biomass >= 50) { btn.disabled = false; btn.innerText = `INJECT (50 Bio)`; }
    else { btn.disabled = true; btn.innerText = selectedUnit.mutations.length>=2?"Unit Full":(selectedDNA?"Need 50 Bio":"Select DNA"); }
}
function injectMutation() {
    if(selectedUnit && selectedDNA && biomass >= 50) {
        biomass -= 50; inventory[selectedDNA]--; selectedUnit.mutations.push(selectedDNA);
        selectedUnit.maxHp+=50; selectedUnit.hp+=50;
        if(inventory[selectedDNA]<=0) selectedDNA=null;
        renderInventory(); updateInspector(); createParticles(selectedUnit.x, selectedUnit.y, "#00ffaa", 20);
    }
}

// -- STARTUP --
for(let i=0; i<4; i++) army.push(new Creature(200, 300 + (i*40), 'blue'));

function loop() {
    ctx.clearRect(0,0,canvas.width,canvas.height); // Clear transparent for background
    gameTime++;

    // PASSIVE INCOME
    if(gameTime % 60 === 0) biomass += 5;

    // SPAWN
    let spawnRate = 0.005; // Very slow spawn
    if(enemies.length < 2 + (army.length/2) && Math.random() < spawnRate) {
        let type = MUTATION_KEYS[Math.floor(Math.random()*MUTATION_KEYS.length)];
        enemies.push(new Creature(canvas.width, Math.random()*canvas.height, 'red', [type]));
    }

    // UPDATE ENTITIES
    [...army, ...enemies].forEach(c => { c.update(); c.draw(); });
    
    // CLEANUP
    for(let i=army.length-1; i>=0; i--) if(army[i].hp<=0) army.splice(i,1);
    for(let i=enemies.length-1; i>=0; i--) {
        if(enemies[i].hp<=0) {
            let type = enemies[i].mutations[0]; if(type) spawnDNA(enemies[i].x, enemies[i].y, type);
            biomass += 20; enemies.splice(i,1);
        }
    }
    for(let i=projectiles.length-1; i>=0; i--) { projectiles[i].update(); projectiles[i].draw(); if(projectiles[i].life<=0) projectiles.splice(i,1); }
    for(let i=items.length-1; i>=0; i--) {
        let it = items[i]; it.life--;
        ctx.fillStyle = MUTATIONS[it.type].color; ctx.beginPath(); 
        ctx.moveTo(it.x, it.y); ctx.lineTo(it.x-5, it.y-10); ctx.lineTo(it.x+5, it.y-10); ctx.fill(); // Vial shape
        ctx.fillStyle="#004466"; ctx.font="10px Arial"; ctx.fillText("DNA", it.x-10, it.y+10);
        if(Math.hypot(mouseX-it.x, mouseY-it.y) < 25) { inventory[it.type]++; renderInventory(); biomass += 5; items.splice(i,1); }
        else if(it.life<=0) items.splice(i,1);
    }
    
    // SNOW PARTICLES
    if(Math.random()<0.3) particles.push({x: Math.random()*canvas.width, y: 0, vx: (Math.random()-0.5), vy: Math.random()*2+1, c: 'white', life: 200});
    for(let i=particles.length-1; i>=0; i--) { let p = particles[i]; p.x+=p.vx; p.y+=p.vy; p.life--; ctx.globalAlpha=p.life/100; ctx.fillStyle=p.c; ctx.beginPath(); ctx.arc(p.x,p.y,Math.random()*2,0,Math.PI*2); ctx.fill(); if(p.life<=0) particles.splice(i,1); }
    ctx.globalAlpha=1;

    document.getElementById('bioDisplay').innerText = biomass;
    if(army.length === 0 && biomass < 50) { ctx.fillStyle = "#004466"; ctx.font = "30px Arial"; ctx.fillText("EXTINCTION EVENT - RELOAD TO RETRY", canvas.width/2-250, canvas.height/2); }
    else requestAnimationFrame(loop);
}

renderInventory();
loop();
</script>
</body>
</html>
